#!/usr/bin/env python3
"""
Rockuefort reads playlists written in simple plaintext, searches your
music library, and outputs the songs matched by the playlist in a few
different ways.

Usage: rockuefort index [--reset] <directory>
       rockuefort list [--strip PREFIX] [--prepend PREFIX] [--null] <playlist>
       rockuefort (copy|link) <playlist> <destination>
       rockuefort render <playlist> <outfile>
       rockuefort --help

Options:
    --null              Terminate printed filenames with null characters
    --prepend PREFIX    Prefix to prepend to each printed filename
    --reset             Forget previously indexed files
    --strip PREFIX      Prefix to strip from each filename
"""
import math
import os
import os.path as path
import pickle
import subprocess
import sys
import tempfile

from docopt import docopt
import mutagenx as mutagen


def ask(question):
    while True:
        answer = input("{} (Y/n): ".format(question))
        if answer in "Yy":
            # Note that this wins if answer is empty
            return True
        elif answer in "Nn":
            return False


def call(args, ignore=False):
    log(' '.join(args))
    try:
        subprocess.check_call(args)
    except subprocess.CalledProcessError as e:
        if not ignore:
            log(e)
            sys.exit(2)


def mkdir_if_needed(path):
    try:
        os.makedirs(path, exist_ok=True)
    except FileExistsError as e:
        if e.errno == 17:
            # 17 means the permissions are abnormal, but we don't care
            pass
        else:
            raise


def index(cache_path, directory, existing_cache=None):
    with open(cache_path, 'wb') as out:
        attrs = ['title', 'artist', 'album', 'genre']
        songs = existing_cache or []
        for base, dirs, files in os.walk(directory):
            for file in (path.abspath(path.join(base, f)) for f in files):
                q = mutagen.File(file, easy=True)
                if q:
                    print(file)
                    song = {attr: q.get(attr, []) for attr in attrs}
                    song['file'] = file
                    songs.append(song)
        pickle.dump(songs, out)


def log(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def make_links(targets, dest_dir):
    digits = len(str(len(targets)))
    for i, target in enumerate(targets, 1):
        basename = ("{:0%d}-{}" % digits).format(i, path.basename(target))
        dest = path.join(dest_dir, basename)
        try:
            os.symlink(target, dest)
        except FileExistsError:
            log("File exists: {}".format(dest))


def normalize(list_or_string):
    # We do substring matching on track attributes, but the attributes come
    # from mutagen as lists of strings (except for the 'file' attribute). So,
    # when given a list we join its items together (surrounding each with
    # quotes so fake full-string matching is possible) and return the result to
    # do substring matching on.
    if isinstance(list_or_string, list):
        return ''.join('"' + s + '"' for s in map(str.lower, list_or_string))
    else:
        return list_or_string.lower()


def parse_entries(lines):
    entries = []
    for line_number, line in enumerate(lines, start=1):
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if line.startswith("+"):
            # TODO: deal with + (means this track must stay with previous)
            line = line[1:]
        try:
            c, rest = line.split(':', 1)
            c = int(c)
        except ValueError:
            c = 1
            rest = line
        parts = rest.lower().split('|')
        queries = [part.split('=') for part in parts]
        entries.append((c, queries, line_number))
    return entries


def load_cache(path):
    with open(path, 'rb') as f:
        songs = pickle.load(f)

    return songs


def render(files, outfile):
    with tempfile.TemporaryDirectory() as temp_dir:
        processed_files = []
        # Pre-process each file to compress dynamics and remove silences
        max_digits = math.ceil(math.log10(len(files)))
        for n, file in enumerate(files, start=1):
            base, _ = path.splitext(path.basename(file))
            out = path.join(temp_dir, ('{:0%sd}-{}.ogg' % max_digits)
                                      .format(n, base))
            sox_args = [
                'sox',
                '--no-clobber',
                '--show-progress',
                '--replay-gain', 'track',
                file,
                out,
                #'compand', '0.5,3',
                #    '5:-70,-60,-40,-40,-25,-30,-20,-20,-15,-10,-8,-5,-5',
                #    '-2', '-70', '0.3',
                'silence', '1', '0.1', '1%', # remove silence at the beginning
                'reverse',
                'silence', '1', '0.1', '1%', # remove silence at the end
                'reverse',
            ]
            call(sox_args)
            processed_files.append(out)

        # Concatenate the files
        sox_args = [
            'sox',
            '--no-clobber',
            '--show-progress',
        ]
        for file in processed_files:
            sox_args.append(file)
        sox_args.append(outfile)
        call(sox_args)


if __name__ == '__main__':
    args = docopt(__doc__)

    cache_path = path.expanduser('~/.cache/rockuefort/index')
    try:
        data = load_cache(cache_path)
    except FileNotFoundError:
        data = None

    if not data and not args['index']:
        print("Invalid cache. Please `rockuefort index` something first.",
              file=sys.stderr)
        sys.exit(1)

    if args['index']:
        mkdir_if_needed(path.dirname(cache_path))
        if args['--reset']:
            data = []
        index(cache_path, args['<directory>'], data)
        sys.exit(0)

    # Load entries
    with open(args['<playlist>']) as f:
        entries = parse_entries(f)

    # Query and build list of files
    files = []
    for c, queries, line_number in entries:
        matched_files = data
        try:
            for attr, value in queries:
                matched_files = [x for x in matched_files
                                 if value in normalize(x[attr])]
        except ValueError:
            log("Skipping malformed entry on line %s" % line_number)
            continue

        matched_files = [x['file'] for x in matched_files]

        # De-duplicate by preferring .ogg, .mp3 versions of songs
        matched_files_exts = {}
        for file in matched_files:
            base, ext = path.splitext(file)
            matched_files_exts.setdefault(base, []).append(ext)
        matched_files_deduped = []
        for base, exts in matched_files_exts.items():
            try:
                ext = next(e for e in ['.ogg', '.mp3'] if e in exts)
            except StopIteration:
                ext = exts[0]
            matched_files_deduped.append(base + ext)

        # Check whether the query matched the expected number of files
        nm = len(matched_files_deduped)
        if nm != c:
            log("Matched {} (expected {}): {}".format(nm, c, queries))
            for file in matched_files_deduped:
                log("  match: {}".format(file))
        for file in matched_files_deduped:
            files.append(file)

    # Perform the requested action
    if args['copy']:
        dest = args['<destination>']
        with tempfile.TemporaryDirectory() as temp_dir:
            make_links(files, temp_dir)
            log("Performing a dry run of rsync...")
            rsync_args = ['rsync', '--recursive', '--itemize-changes',
                          '--copy-links', '--times', '--delete', '--dry-run',
                          temp_dir + '/', dest]
            try:
                call(rsync_args, ignore=True)
            except subprocess.CalledProcessError:
                pass
            if ask("Proceed with the rsync?"):
                rsync_args.remove('--dry-run')
                try:
                    call(rsync_args, ignore=True)
                except subprocess.CalledProcessError:
                    pass
    elif args['link']:
        dest = args['<destination>']
        try:
            os.mkdir(dest)
        except FileExistsError:
            pass
        make_links(files, dest)
    elif args['render']:
        outfile = args['<outfile>']
        render(files, outfile)
    elif args['list']:
        for file in files:
            if args['--strip'] and file.startswith(args['--strip']):
                file = file[len(args['--strip']):]
            if args['--prepend']:
                file = args['--prepend'] + file
            print(file, end=('\0' if args['--null'] else '\n'))
    else:
        class DocoptConfidenceError(Exception): pass
        raise DocoptConfidenceError("Docopt, you've failed us!")
